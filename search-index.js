var searchIndex = {};
searchIndex["rose_tree"] = {"doc":"","items":[[11,"new","petgraph::graph","",0,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[11,"index","","",0,null],[11,"end","","",0,{"inputs":[],"output":{"name":"nodeindex"}}],[11,"fmt","petgraph::scored","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"clone","petgraph::graphmap","",2,null],[11,"fmt","","",2,null],[11,"new","","Create a new `GraphMap`.",2,{"inputs":[],"output":{"name":"graphmap"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"graphmap"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",2,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",2,{"inputs":[{"name":"i"}],"output":{"name":"graphmap"}}],[11,"node_count","","Return the number of nodes in the graph.",2,null],[11,"edge_count","","Return the number of edges in the graph.",2,null],[11,"clear","","Remove all nodes and edges",2,null],[11,"add_node","","Add node `n` to the graph.",2,null],[11,"remove_node","","Return `true` if node `n` was removed.",2,null],[11,"contains_node","","Return `true` if the node is contained in the graph.",2,null],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph.",2,null],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",2,null],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",2,null],[11,"nodes","","Return an iterator over the nodes of the graph.",2,null],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",2,null],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",2,null],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,null],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,null],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",2,null],[11,"from_iter","","",2,{"inputs":[{"name":"i"}],"output":{"name":"graphmap"}}],[11,"extend","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"next_back","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"next","","",5,null],[11,"next","","",6,null],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"hash","petgraph::graph","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"from","","",0,{"inputs":[{"name":"ix"}],"output":{"name":"nodeindex"}}],[11,"hash","","",7,null],[11,"cmp","","",7,null],[11,"partial_cmp","","",7,null],[11,"lt","","",7,null],[11,"le","","",7,null],[11,"gt","","",7,null],[11,"ge","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"clone","","",7,null],[11,"new","","",7,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[11,"index","","",7,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",7,{"inputs":[],"output":{"name":"edgeindex"}}],[11,"fmt","","",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",9,null],[11,"source","","Return the source node index.",9,null],[11,"target","","Return the target node index.",9,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"new","","Create a new `Graph` with directed edges.",10,{"inputs":[],"output":{"name":"graph"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",10,{"inputs":[],"output":{"name":"graph"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",10,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"graph"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",10,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",10,null],[11,"edge_count","","Return the number of edges in the graph.",10,null],[11,"is_directed","","Whether the graph has directed edges or not.",10,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",10,null],[11,"node_weight","","Access node weight for node `a`.",10,null],[11,"node_weight_mut","","Access node weight for node `a`.",10,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",10,null],[11,"update_edge","","Add or update an edge from `a` to `b`.",10,null],[11,"edge_weight","","Access the edge weight for `e`.",10,null],[11,"edge_weight_mut","","Access the edge weight for `e` mutably.",10,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",10,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",10,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",10,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",10,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",10,null],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",10,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",10,null],[11,"edges_both","","Return an iterator over the edgs from `a` to its neighbors, then *to* `a` from its\nneighbors.",10,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",10,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",10,null],[11,"without_edges","","Return an iterator over either the nodes without edges to them or from them.",10,null],[11,"node_indices","","Return an iterator over the node indices of the graph",10,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",10,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",10,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",10,null],[11,"raw_nodes","","Access the internal node array.",10,null],[11,"raw_edges","","Access the internal edge array.",10,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",10,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",10,null],[11,"walk_edges_directed","","Return a “walker” object that can be used to step through the edges\nof the node `a` in direction `dir`.",10,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",10,null],[11,"reverse","","Reverse the direction of all edges",10,null],[11,"clear","","Remove all nodes and edges",10,null],[11,"clear_edges","","Remove all edges",10,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",10,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",10,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",10,{"inputs":[{"name":"i"}],"output":{"name":"graph"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",10,null],[11,"map","","Create a new `Graph` by mapping node and edge weights.",10,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",10,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",10,null],[11,"next","","",11,null],[11,"next","","",12,null],[11,"next","","",13,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"index","","",0,null],[11,"is_node_index","","",0,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",7,null],[11,"is_node_index","","",7,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"next","","Fetch the next edge index in the walk for graph `g`.",16,null],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",16,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"next_back","","",17,null],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"next_back","","",18,null],[11,"new","petgraph::dot","Create a `Dot` formatting wrapper with default configuration.",19,{"inputs":[{"name":"g"}],"output":{"name":"dot"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",19,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"fmt","","",20,null],[11,"fmt","","",19,null],[11,"fmt","","",19,null],[11,"fmt","","",19,null],[11,"fmt","","",19,null],[11,"neighbors","petgraph::graph","",10,null],[11,"neighbors","petgraph::graphmap","",2,null],[11,"neighbors","petgraph::visit","",21,null],[11,"neighbors","","",22,null],[11,"neighbors_directed","petgraph::graph","",10,null],[11,"neighbors_directed","petgraph::visit","",22,null],[11,"externals","petgraph::graph","",10,null],[11,"externals","petgraph::visit","",22,null],[11,"visit","fixedbitset","",23,null],[11,"is_visited","","",23,null],[11,"visit","","",23,null],[11,"is_visited","","",23,null],[11,"visit","std::collections::hash::set","",24,null],[11,"is_visited","","",24,null],[11,"visit_map","petgraph::graph","",10,null],[11,"reset_map","","",10,null],[11,"reset_map","petgraph::visit","",22,null],[11,"visit_map","petgraph::graphmap","",2,null],[11,"reset_map","","",2,null],[11,"visit_map","petgraph::visit","",21,null],[11,"visit_map","","",22,null],[11,"adjacency_matrix","petgraph::graphmap","",2,null],[11,"is_adjacent","","",2,null],[11,"fmt","petgraph::visit","",25,null],[11,"clone","","",25,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",25,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"dfs"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",25,{"inputs":[{"name":"g"}],"output":{"name":"dfs"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",25,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",25,null],[11,"new","","",26,null],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"clone","","",26,null],[11,"clone","","",27,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",27,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"bfs"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",27,null],[11,"new","","",28,null],[11,"next","","",28,null],[11,"size_hint","","",28,null],[11,"clone","","",28,null],[11,"clone","","",29,null],[11,"new","","Create a new **Topo**, using the graph&#39;s visitor map, and put all\ninitial nodes in the to visit list.",29,{"inputs":[{"name":"g"}],"output":{"name":"topo"}}],[11,"reset","","Clear visited state, and put all initial nodes in the to visit list.",29,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at end.",29,null],[11,"clone","petgraph::unionfind","",30,null],[11,"fmt","","",30,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",30,{"inputs":[{"name":"usize"}],"output":{"name":"unionfind"}}],[11,"find","","Return the representative for `x`.",30,null],[11,"find_mut","","Return the representative for `x`.",30,null],[11,"union","","Unify the two sets containing `x` and `y`.",30,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",30,null],[11,"adjacency_matrix","petgraph::graph","",10,null],[11,"is_adjacent","","",10,null],[11,"eq","petgraph","",31,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"is_directed","","",32,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",33,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",34,null],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",34,null],[11,"partial_cmp","","",34,null],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",34,null],[11,"deref","","",34,null],[11,"hash","","",34,null],[11,"fmt","","",34,null],[3,"NodeIndex","rose_tree","Node identifier.",null,null],[3,"RoseTree","","An indexable tree data structure with a variable and unbounded number of branches per node.",null,null],[3,"ParentRecursion","","An iterator that yeilds an index to the parent of the current child before the setting the\nparent as the new current child. This occurs recursively until the root index is yeilded.",null,null],[3,"Siblings","","An iterator yielding indices to the siblings of some child node.",null,null],[3,"WalkChildren","","A &quot;walker&quot; object that can be used to step through the children of some parent node.",null,null],[3,"WalkSiblings","","A &quot;walker&quot; object that can be used to step through the siblings of some child node.",null,null],[6,"PetGraph","","The PetGraph to be used internally within the RoseTree for storing/managing nodes and edges.",null,null],[6,"Children","","An iterator yielding indices to the children of some node.",null,null],[17,"ROOT","","`RoseTree`&#39;s API ensures that it always has a &quot;root&quot; node and that its index is always 0.",null,null],[11,"fmt","","",35,null],[11,"clone","","",35,null],[11,"new","","Create a new `RoseTree` along with some root node.\nReturns both the `RoseTree` and an index into the root node in a tuple.",35,null],[11,"with_capacity","","Create a new `RoseTree` with estimated capacity and some root node.\nReturns both the `RoseTree` and an index into the root node in a tuple.",35,null],[11,"node_count","","The total number of nodes in the RoseTree.",35,null],[11,"graph","","Borrow the `RoseTree`&#39;s underlying `PetGraph&lt;N, Ix&gt;`.\nAll existing `NodeIndex`s may be used to index into this graph the same way they may be\nused to index into the `RoseTree`.",35,null],[11,"into_graph","","Take ownership of the RoseTree and return the internal PetGraph&lt;N, Ix&gt;.\nAll existing `NodeIndex`s may be used to index into this graph the same way they may be\nused to index into the `RoseTree`.",35,null],[11,"add_child","","Add a child node to the node at the given NodeIndex.\nReturns an index into the child&#39;s position within the tree.",35,null],[11,"node_weight","","Borrow the weight from the node at the given index.",35,null],[11,"node_weight_mut","","Mutably borrow the weight from the node at the given index.",35,null],[11,"index_twice_mut","","Index the `RoseTree` by two node indices.",35,null],[11,"remove_all_but_root","","Remove all nodes in the `RoseTree` except for the root.",35,null],[11,"remove_node","","Removes and returns the node at the given index.",35,null],[11,"remove_node_with_children","","Removes the node at the given index along with all their children, returning them as a new\nRoseTree.",35,null],[11,"parent","","An index to the parent of the node at the given index if there is one.",35,null],[11,"parent_recursion","","An iterator over the given child&#39;s parent, that parent&#39;s parent and so forth.",35,null],[11,"children","","An iterator over all nodes that are children to the node at the given index.",35,null],[11,"walk_children","","A &quot;walker&quot; object that may be used to step through the children of the given parent node.",35,null],[11,"siblings","","An iterator over all nodes that are siblings to the node at the given index.",35,null],[11,"walk_siblings","","A &quot;walker&quot; object that may be used to step through the siblings of the given child node.",35,null],[11,"index","","",35,null],[11,"index_mut","","",35,null],[11,"next","","",36,null],[11,"next","","",37,null],[11,"next","","Fetch the next child index in the walk for the given `RoseTree`.",38,null],[11,"next","","Fetch the next sibling index in the walk for the given `RoseTree`.",39,null]],"paths":[[3,"NodeIndex"],[3,"MinScored"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Edges"],[3,"AllEdges"],[3,"EdgeIndex"],[3,"Node"],[3,"Edge"],[3,"Graph"],[3,"WithoutEdges"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[3,"Dot"],[4,"Config"],[3,"AsUndirected"],[3,"Reversed"],[3,"FixedBitSet"],[3,"HashSet"],[3,"Dfs"],[3,"DfsIter"],[3,"Bfs"],[3,"BfsIter"],[3,"Topo"],[3,"UnionFind"],[4,"EdgeDirection"],[3,"Directed"],[3,"Undirected"],[3,"Ptr"],[3,"RoseTree"],[3,"Siblings"],[3,"ParentRecursion"],[3,"WalkChildren"],[3,"WalkSiblings"]]};
searchIndex["petgraph"] = {"doc":"**petgraph** is a graph data structure library.","items":[[3,"MinScored","petgraph","`MinScored&lt;K, T&gt;` holds a score `K` and a scored object `T` in\na pair for use with a `BinaryHeap`.",null,null],[12,"0","","",0,null],[12,"1","","",0,null],[3,"Directed","","Marker type for a directed graph.",null,null],[3,"Undirected","","Marker type for an undirected graph.",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[12,"0","","",1,null],[4,"EdgeDirection","","Edge direction",null,null],[13,"Outgoing","","An `Outgoing` edge is an outward edge *from* the current node.",2,null],[13,"Incoming","","An `Incoming` edge is an inbound edge *to* the current node.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra&#39;s shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return `true` if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to `is_cyclic_undirected`.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Return `true` if the input directed graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute the *strongly connected components* using Kosaraju&#39;s algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Compute a *minimum spanning tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"graphmap","petgraph","`GraphMap&lt;N, E&gt;` is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","`GraphMap&lt;N, E&gt;` is an undirected graph, with generic node values `N` and edge weights `E`.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[12,"from","","**Deprecated: should be private**",3,null],[12,"edges","","**Deprecated: should be private**",3,null],[12,"iter","","**Deprecated: should be private**",3,null],[3,"AllEdges","","",null,null],[8,"NodeTrait","","A trait group for `GraphMap`&#39;s node identifier.",null,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"new","","Create a new `GraphMap`.",4,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",4,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",4,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes in the graph.",4,null],[11,"edge_count","","Return the number of edges in the graph.",4,null],[11,"clear","","Remove all nodes and edges",4,null],[11,"add_node","","Add node `n` to the graph.",4,null],[11,"remove_node","","Return `true` if node `n` was removed.",4,null],[11,"contains_node","","Return `true` if the node is contained in the graph.",4,null],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph.",4,null],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",4,null],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",4,null],[11,"nodes","","Return an iterator over the nodes of the graph.",4,null],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",4,null],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",4,null],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",4,null],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",4,null],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",4,null],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"next_back","","",6,null],[11,"next","","",3,null],[11,"next","","",7,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[0,"graph","petgraph","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph&#39;s node type.",null,null],[12,"weight","","Associated node data.",8,null],[3,"Edge","","The graph&#39;s edge type.",null,null],[12,"weight","","Associated edge data.",9,null],[3,"Graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"WithoutEdges","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"WalkEdges","","A “walker” object that can be used to step through the edge list of a node.",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[3,"EdgeIndices","","Iterator over the edge indices of a graph.",null,null],[5,"node_index","","Short version of `NodeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[5,"edge_index","","Short version of `EdgeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[6,"DefIndex","","The default integer type for node and edge indices in `Graph`.\n`u32` is the default to reduce the size of the graph&#39;s data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",10,null],[10,"max","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"zero","","**Deprecated**",10,{"inputs":[],"output":{"name":"self"}}],[11,"one","","**Deprecated**",10,{"inputs":[],"output":{"name":"self"}}],[8,"GraphIndex","","A  `GraphIndex` is a node or edge index.",null,null],[11,"hash","","",11,null],[11,"cmp","","",11,null],[11,"partial_cmp","","",11,null],[11,"lt","","",11,null],[11,"le","","",11,null],[11,"gt","","",11,null],[11,"ge","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"new","","",11,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",11,null],[11,"end","","",11,{"inputs":[],"output":{"name":"self"}}],[11,"from","","",11,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"hash","","",12,null],[11,"cmp","","",12,null],[11,"partial_cmp","","",12,null],[11,"lt","","",12,null],[11,"le","","",12,null],[11,"gt","","",12,null],[11,"ge","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"clone","","",12,null],[11,"new","","",12,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",12,null],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",12,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",12,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",9,null],[11,"source","","Return the source node index.",9,null],[11,"target","","Return the target node index.",9,null],[11,"clone","","",13,null],[11,"fmt","","",13,null],[11,"new","","Create a new `Graph` with directed edges.",13,{"inputs":[],"output":{"name":"self"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",13,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",13,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",13,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",13,null],[11,"edge_count","","Return the number of edges in the graph.",13,null],[11,"is_directed","","Whether the graph has directed edges or not.",13,null],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",13,null],[11,"node_weight","","Access node weight for node `a`.",13,null],[11,"node_weight_mut","","Access node weight for node `a`.",13,null],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",13,null],[11,"update_edge","","Add or update an edge from `a` to `b`.",13,null],[11,"edge_weight","","Access the edge weight for `e`.",13,null],[11,"edge_weight_mut","","Access the edge weight for `e` mutably.",13,null],[11,"edge_endpoints","","Access the source and target nodes for `e`.",13,null],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",13,null],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",13,null],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",13,null],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",13,null],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",13,null],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",13,null],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",13,null],[11,"edges_both","","Return an iterator over the edgs from `a` to its neighbors, then *to* `a` from its\nneighbors.",13,null],[11,"find_edge","","Lookup an edge from `a` to `b`.",13,null],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",13,null],[11,"without_edges","","Return an iterator over either the nodes without edges to them or from them.",13,null],[11,"node_indices","","Return an iterator over the node indices of the graph",13,null],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",13,null],[11,"edge_indices","","Return an iterator over the edge indices of the graph",13,null],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",13,null],[11,"raw_nodes","","Access the internal node array.",13,null],[11,"raw_edges","","Access the internal edge array.",13,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",13,null],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",13,null],[11,"walk_edges_directed","","Return a “walker” object that can be used to step through the edges\nof the node `a` in direction `dir`.",13,null],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",13,null],[11,"reverse","","Reverse the direction of all edges",13,null],[11,"clear","","Remove all nodes and edges",13,null],[11,"clear_edges","","Remove all edges",13,null],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",13,null],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",13,null],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",13,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",13,null],[11,"map","","Create a new `Graph` by mapping node and edge weights.",13,null],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",13,null],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",13,null],[11,"next","","",14,null],[11,"next","","",15,null],[11,"next","","",16,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"index","","",13,null],[11,"index_mut","","",13,null],[11,"index","","",13,null],[11,"index_mut","","",13,null],[11,"index","","",11,null],[11,"is_node_index","","",11,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",12,null],[11,"is_node_index","","",12,{"inputs":[],"output":{"name":"bool"}}],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"next","","Fetch the next edge index in the walk for graph `g`.",19,null],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",19,null],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"next_back","","",20,null],[11,"next","","",21,null],[11,"size_hint","","",21,null],[11,"next_back","","",21,null],[0,"dot","petgraph","Simple graphviz dot file format output.",null,null],[3,"Dot","petgraph::dot","`Dot` implements output to graphviz .dot format for a graph.",null,null],[4,"Config","","`Dot` configuration.",null,null],[13,"NodeIndexLabel","","Use indices for node labels.",22,null],[13,"EdgeIndexLabel","","Use indices for edge labels.",22,null],[13,"EdgeNoLabel","","Use no edge labels.",22,null],[11,"new","","Create a `Dot` formatting wrapper with default configuration.",23,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",23,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"fmt","","",22,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[11,"fmt","","",23,null],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[12,"0","","",24,null],[3,"Reversed","","Wrapper type for walking edges the other way",null,null],[12,"0","","",25,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","The stack of nodes to visit",26,null],[12,"discovered","","The map of discovered nodes",26,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",27,null],[12,"discovered","","The map of discovered nodes",27,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[3,"Topo","","A topological order traversal for a graph.",null,null],[8,"Graphlike","","Base trait for graphs that defines the node identifier.",null,null],[16,"NodeId","","",28,null],[8,"NeighborIter","","A graph trait for accessing the neighbors iterator",null,null],[16,"Iter","","",29,null],[10,"neighbors","","Return an iterator that visits all neighbors of the node **n**.",29,null],[8,"NeighborsDirected","","NeighborsDirected gives access to neighbors of both `Incoming` and `Outgoing`\nedges of a node.",null,null],[16,"NeighborsDirected","","",30,null],[10,"neighbors_directed","","Return an iterator that visits all neighbors of the node **n**.",30,null],[8,"Externals","","Externals returns an iterator of all nodes that either have either no\nincoming or no outgoing edges.",null,null],[16,"Externals","","",31,null],[10,"externals","","Return an iterator of all nodes with no edges in the given direction",31,null],[8,"VisitMap","","A mapping from node → is_visited.",null,null],[10,"visit","","Return **true** if the value is not already present.",32,null],[10,"is_visited","","",32,null],[8,"Visitable","","Trait for which datastructure to use for a graph’s visitor map",null,null],[16,"Map","","",33,null],[10,"visit_map","","",33,null],[8,"Revisitable","","Trait for graph that can reset &amp; resize its visitor map",null,null],[10,"reset_map","","",34,null],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","","",35,null],[10,"adjacency_matrix","","",35,null],[10,"is_adjacent","","",35,null],[11,"neighbors","petgraph::graph","",13,null],[11,"neighbors","petgraph::graphmap","",4,null],[11,"neighbors","petgraph::visit","",24,null],[11,"neighbors","","",25,null],[11,"neighbors_directed","petgraph::graph","",13,null],[11,"neighbors_directed","petgraph::visit","",25,null],[11,"externals","petgraph::graph","",13,null],[11,"externals","petgraph::visit","",25,null],[11,"visit","fixedbitset","",36,null],[11,"is_visited","","",36,null],[11,"visit","","",36,null],[11,"is_visited","","",36,null],[11,"visit","std::collections::hash::set","",37,null],[11,"is_visited","","",37,null],[11,"visit_map","petgraph::graph","",13,null],[11,"reset_map","","",13,null],[11,"reset_map","petgraph::visit","",25,null],[11,"visit_map","petgraph::graphmap","",4,null],[11,"reset_map","","",4,null],[11,"visit_map","petgraph::visit","",24,null],[11,"visit_map","","",25,null],[11,"adjacency_matrix","petgraph::graphmap","",4,null],[11,"is_adjacent","","",4,null],[11,"fmt","petgraph::visit","",26,null],[11,"clone","","",26,null],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",26,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",26,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",26,null],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",26,null],[11,"new","","",38,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",38,null],[11,"next","","",38,null],[11,"size_hint","","",38,null],[11,"clone","","",38,null],[11,"clone","","",27,null],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",27,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",27,null],[11,"new","","",39,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"next","","",39,null],[11,"size_hint","","",39,null],[11,"clone","","",39,null],[11,"clone","","",40,null],[11,"new","","Create a new **Topo**, using the graph&#39;s visitor map, and put all\ninitial nodes in the to visit list.",40,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear visited state, and put all initial nodes in the to visit list.",40,null],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at end.",40,null],[0,"unionfind","petgraph","`UnionFind&lt;K&gt;` is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","`UnionFind&lt;K&gt;` is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.",null,null],[11,"clone","","",41,null],[11,"fmt","","",41,null],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",41,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for `x`.",41,null],[11,"find_mut","","Return the representative for `x`.",41,null],[11,"union","","Unify the two sets containing `x` and `y`.",41,null],[11,"into_labeling","","Return a vector mapping each element to its representative.",41,null],[11,"adjacency_matrix","petgraph::graph","",13,null],[11,"is_adjacent","","",13,null],[8,"EdgeType","petgraph","A graph&#39;s edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",42,{"inputs":[],"output":{"name":"bool"}}],[8,"IntoWeightedEdge","","Convert an element like `(i, j)` or `(i, j, w)` into\na triple of source, target, edge weight.",null,null],[10,"into_weighted_edge","","",43,null],[11,"eq","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"is_directed","","",44,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",45,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",1,null],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",1,null],[11,"deref","","",1,null],[11,"hash","","",1,null],[11,"fmt","","",1,null]],"paths":[[3,"MinScored"],[3,"Ptr"],[4,"EdgeDirection"],[3,"Edges"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"AllEdges"],[3,"Node"],[3,"Edge"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"WithoutEdges"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[4,"Config"],[3,"Dot"],[3,"AsUndirected"],[3,"Reversed"],[3,"Dfs"],[3,"Bfs"],[8,"Graphlike"],[8,"NeighborIter"],[8,"NeighborsDirected"],[8,"Externals"],[8,"VisitMap"],[8,"Visitable"],[8,"Revisitable"],[8,"GetAdjacencyMatrix"],[3,"FixedBitSet"],[3,"HashSet"],[3,"DfsIter"],[3,"BfsIter"],[3,"Topo"],[3,"UnionFind"],[8,"EdgeType"],[8,"IntoWeightedEdge"],[3,"Directed"],[3,"Undirected"]]};
searchIndex["fixedbitset"] = {"doc":"**FixedBitSet** is a simple fixed size set of bits.","items":[[3,"FixedBitSet","fixedbitset","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"grow","","Grow capacity to **bits**, all new bits initialized to zero",0,null],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,null],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,null],[11,"clear","","Clear all bits.",0,null],[11,"insert","","**Panics** if **bit** is out of bounds.",0,null],[11,"set","","**Panics** if **bit** is out of bounds.",0,null],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,null],[11,"index","","",0,null]],"paths":[[3,"FixedBitSet"]]};
initSearch(searchIndex);
